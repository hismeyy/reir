---
title: 编程通用概念
author: MaxCosmos
createTime: 2024/07/07 00:00:00
permalink: /study-beginner/3/
---

## 不可变变量和可变变量

在 `rust` 中声明一个变量是通过 `let` 来声明的。但是一个变量默认是不可变的。也就是后面无法修改这个变量的值。如果想声明一个可变的变量，必须加 `mut` 关键字。

```rust
fn main() {
    let x = 5;
	println!("x = {}", x);
	x = 6;
	println!("x = {}", x);
}


error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:2
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("x = {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

如果我们修改了不可变变量，编译的时候就会提示 `cannot assign twice to immutable variable x` ，并且编译器也会告诉我们，需要使用 `mut` 来声明变量。 

## 常量

常量和不可变的变量是不一样的，常量声明需要用 `const` ，并且必须要标注值得类型。Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词。

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

## 遮蔽

Rust 还有一个特殊得地方是允许变量进行遮蔽。也就是允许局部变量在局部得范围内重新被定义，但是不会影响外部的变量值。

```rust
fn main() {
    let x = 5;
	println!("x = {}", x);
	
	{
		let x = 6;
		println!("x = {}", x);
	}
	
	println!("x = {}", x);
}

x = 5
x = 6
x = 5
```

如上面的代码，我们在外部声明了 x 为 5，到了局部的时候，把 x 遮蔽了变成 6，但是他不会影响外部的 x。因此外部的 x还是 5。

### 遮蔽和 mut 的区别

遮蔽是重新给变量设置类型和值。而 mut 则是在当前变量的类型上修改值。比如：

```rust
let spaces = "   ";
let spaces = spaces.len();
```

一开始 `spaces` 的值是空格，类型是字符类型，而遮蔽后类型变成了整数类型，值也从空格修改成空格的长度。

```rust
let mut spaces = "   ";
spaces = spaces.len();

error[E0308]: mismatched types
 --> src/main.rs:3:11
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`
```

如果我们使用 `mut` 编译的时候就会报错。`mismatched types` 提示不匹配类型。原本人家是字符类型，你非要给他一个整数类型，那肯定是不对的！

## 数据类型

rust 是一个静态类型语言，也就是说在编译的时候就要知道所有变量的类型。

### 标量类型

**标量**（ scalar ）类型表示单个值。Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符。

1. 整数类型

   **整数**（*integer*）是没有小数部分的数字。

   | 长度   | 有符号类型 | 无符号类型 |
   | ------ | ---------- | ---------- |
   | 8 位   | i8         | u8         |
   | 16 位  | i16        | u16        |
   | 32 位  | i32        | u32        |
   | 64 位  | i64        | u64        |
   | 128 位 | i128       | u128       |
   | arch   | isize      | usize      |

   > `isize` 和 `usize` 类型取决于程序运行的计算机体系结构，在表中表示为 arch ：若使用 64 位架构系统则为 64 位，若使用 32 位架构系统则为 32 位。

   | 数字字面量         | 示例        |
   | ------------------ | ----------- |
   | 十进制             | 98_222      |
   | 十六进制           | 0xff        |
   | 八进制             | 0o77        |
   | 二进制             | 0b1111_0000 |
   | 字节 (仅限于 `u8`) | b'A'        |

   rust默认类型是 `i32`。`isize` 和 `usize` 的主要应用场景是用作某些集合的索引。

   > 整数溢出
   > TODO

2. 浮点类型

   **浮点数**（*floating-point number*）是带有小数点的数字，在 Rust 中浮点类型（简称浮点型）数字也有两种基本类型。Rust 的浮点型是 `f32` （ 单精度浮点型 ）和 `f64` （双精度浮点型），它们的大小分别为 32 位和 64 位。默认浮点类型是 `f64`，因为在现代的 CPU 中它的速度与 `f32` 的几乎相同，但精度更高。所有浮点型都是有符号的。

3. 数字运算

   Rust 的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取模运算。整数除法会向下取整。

   ```rust
   fn main() {
       // addition
       let sum = 5 + 10;
   
       // subtraction
       let difference = 95.5 - 4.3;
   
       // multiplication
       let product = 4 * 30;
   
       // division
       let quotient = 56.7 / 32.2;
       let floored = 2 / 3; // Results in 0
   
       // remainder
       let remainder = 43 % 5;
   }
   ```

   > [Rust 提供的所有运算符的列表](https://rustwiki.org/zh-CN/book/appendix-02-operators.html)

4. 布尔类型

   Rust 中的布尔类型也有两个可能的值：`true` 和 `false`。

5. 字符类型

   Rust 的 `char`（字符）类型是该语言最基本的字母类型。

   ```rust
   fn main() {
       let c = 'z';
       let z = 'ℤ';
       let heart_eyed_cat = '😻';
   }
   ```

   > `char` 字面量采用单引号括。字符串字面量是用双引号括起来。Rust 的字符类型大小为 4 个字节，表示的是一个 Unicode 标量值。

### 复合类型

**复合类型**（*compound type*）可以将多个值组合成一个类型。Rust 有两种基本的复合类型：元组（ tuple ）和数组（ array ）。

1. 元组类型

   元组中每个元素可以是任意一个类型。元组的长度是固定的，只要声明后就无法改变。

   ```rust
   fn main() {
       let tup: (i32, f64, u8) = (500, 6.4, 1);
   }
   ```

   访问元组的时候可以用两种方式：解构或者使用索引`.`。

   ```rust
   // 解构
   fn main() {
       let tup = (500, 6.4, 1);
   
       let (x, y, z) = tup;
   
       println!("The value of y is: {}", y);
   }
   
   // 使用索引 .
   fn main() {
       let x: (i32, f64, u8) = (500, 6.4, 1);
   
       let five_hundred = x.0;
   
       let six_point_four = x.1;
   
       let one = x.2;
   }
   ```

2. 数组类型

   与元组不同，数组的每一个元素必须是相同的类型。

   ```rust
   fn main() {
   	// 初始化数组
       let a = [1, 2, 3, 4, 5];
       // 指定元素类型 并且长度是5
       let b: [i32; 5] = [1, 2, 3, 4, 5];
       // 初始化长度为5，每个元素都是3的数组
       let a = [3; 5];
   }
   ```

   访问数组使用索引访问。

   ```rust
   fn main() {
       let a = [1, 2, 3, 4, 5];
   
       let first = a[0];
       let second = a[1];
   }
   ```

   数组下表越界，如果是运行时越界，是只能在运行时检测出来的，编译的时候是无法检测的。

## 函数

1. 使用关键字 `fn` ；
2. `main` 是主函数，程序的入口；
3. 函数和变量名使用下划线命名法（*snake case*，直译为蛇形命名法）规范风格；
4. 被调用的函数，可以在调用函数的后面或者前面；
5. 定义函数的参数时，必须指定参数类型。

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
```

### 语句和表达式

语句是没有返回值的。

```rust
fn main() {
	// 是一个语句
    let y = 6;
    // 语句没有返回值，所以不能把语句赋值给x
    let x = (let y = 6);
}
```

表达式是有返回值的，表达式是语句的一部分，表达式的最后一行没有分号。

```rust
fn main() {
	// {} 中是一个表达式
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}

```

### 带有返回值的函数

函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（`->`）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 `return` 关键字和指定值，可以从函数中提前返回；但大部分函数隐式返回最后一个表达式。

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

## 注释

```rust
// 表示一个注释
```

## 控制流

### if表达式

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

在 `let` 语句中使用 `if`

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```

意思呢，就是如果 `condition` 是 `true`，那么 `number` 就等于 5，反之为 6。大括号中是一个表达式。并且分支表达式返回的类型也要一致。

### 循环

Rust 有三种循环：`loop`、`while` 和 `for`。

1. loop

   ```rust
   fn main() {
       loop {
           println!("again!");
       }
   }
   ```

   告诉某一段代码需要重复执行。与其他语言一样，`break` 可以跳出循环，`continue` 则是继续下一个循环。

   `loop` 可以接受返回。

   ```rust
   fn main() {
       let mut counter = 0;
   
       let result = loop {
           counter += 1;
   
           if counter == 10 {
               break counter * 2;
           }
       };
   
       println!("The result is {}", result);
   }
   ```

   在循环结束时， `result` 接受到了 `counter * 2` 的值。

2. while

   和其他语言类似，条件为真时循环。

   ```rust
   fn main() {
       let mut number = 3;
   
       while number != 0 {
           println!("{}!", number);
   
           number -= 1;
       }
   
       println!("LIFTOFF!!!");
   }
   ```

3. for

   遍历数组

   ```rust
   fn main() {
       let a = [10, 20, 30, 40, 50];
   
       for element in a {
           println!("the value is: {}", element);
       }
   }
   ```

   遍历数字

   ```rust
   fn main() {
       for number in 1..4 {
           println!("{}!", number);
       }
       println!("LIFTOFF!!!");
   }
   ```

   >`rev` 可以反转区间 (range)
   >
   >```rust
   >fn main() {
   >    for number in (1..4).rev() {
   >        println!("{}!", number);
   >    }
   >    println!("LIFTOFF!!!");
   >}
   >```
