---
title: 所有权
author: MaxCosmos
createTime: 2024/07/08 00:00:00
permalink: /study-beginner/4/
---

> rust无需垃圾回收器就可以保证内存安全！靠的就是所有权。

## 什么是所有权

在计算机中，值会存储在堆和栈中。如果值的大小是确定的，就可以存储在栈中，比如一些基本数据类型。如果大小不确定，那么它就会存储在堆中（比如 Java 中的引用类型）。此时会有一个指针变量存储在栈中，它会指向堆中的数据。简单来说，知道大小的值存在栈中，不知道大小的值存在堆中，同时有一个固定大小的指针存在栈中，指向堆中的数据。如下图所示：

![image-20240711192424991](http://maximg.maxcosmos.top/blog-img/image-20240711192424991.png)

代码的执行实际上就是不断地压栈和弹栈（栈是先进后出）。在 Rust 中，当代码块执行完毕时，会调用 `Drop` 函数，释放该代码块中的数据。我们需要做的事情是，将需要使用的数据克隆或者移动到其他地方，或者通过借用的方式来使用这些数据。因为在 Rust 中，同一块堆中的数据在同一时刻只能被一个变量拥有。

可以将其类比为一个班级中的一本书，在同一时刻，这本书只能被一个同学拥有。如果其他同学想看书，就需要当前的同学把书给他，或者他抄写一份，或者借用一段时间并在规定时间内归还。只要理解了这个类比，就能理解 Rust 的所有权机制。

下面我们来说说 `rust` 中是如何进行所有权的移动、克隆和借用的！

## 移动

> 我把一本书给另一个同学。

ruts 中移动，就是把指向的数据的权限，交给另一个变量。前提是在同一个代码块中。看下面的图。

![image-20240711201756773](http://maximg.maxcosmos.top/blog-img/image-20240711201756773.png)

代码写就是这样的。

```rust
fn main() {
    let y = String::from("hello"); // 我拥有一本书
    let x = y; // 移动到另一个同学受众，我就没有这本书的所有权了
} // 结束的时候会调用 Drop x就会被释放
```

## 克隆

> 我不给，另一个同学自己抄一遍。

rust 中的克隆，其实就是把数据全部在堆中复制一遍。并且让最新的变量指向这个复制后的值。

![image-20240711202354266](http://maximg.maxcosmos.top/blog-img/image-20240711202354266.png)

代码是这样的。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
}
```

rust 中 标量类型是可以直接在栈上拷贝的。别问，问就是它的大小固定。

```rust
fn main() {
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
}
```

## 借用

> 我不给，但是我可以先接你看看。

对于函数来说，同样会发送移动和克隆。比如：

```rust
fn main() {
  let s = String::from("hello");  // s 进入作用域

  takes_ownership(s);             // s 的值移动到函数里 ...
                                  // ... 所以到这里不再有效

  let x = 5;                      // x 进入作用域

  makes_copy(x);                  // x 应该移动函数里，
                                  // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
  println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
  println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作

```

那么问题来了，我不想直接把所有权给某个函数，因为我在函数的后面可能还要用这个值。那怎么办？OK，上借用。

我只需要把指向某个值的指针给你，你先拿着用，然后用完了你释放掉，我还可以继续使用，就可以了！

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

就像上面的代码，`&s1` 就是借用（引用），它相当于借用了 `s1` 指向的值。所以在 `s.len()` 结束后，并没有把 `s1` 释放掉。而是释放了他的一个借用。

那如果我们想修改 `s1` 的值呢？那我们就把借用变成可变借用。

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

需要注意的是！rust 中在同一时间，只能有一个对某一特定数据的**可变引用**（不可变的引用时不限制的）。尝试创建两个可变引用的代码将会失败。比如下面这个，就是不对滴！

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}


$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
```

还有一个注意的就是，引用离开时就要被释放，所以像下面这样，也是不可以的！

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle 返回一个字符串的引用

    let s = String::from("hello"); // s 是一个新字符串

    &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
  // 危险！
```

解决这个办法的方式就是，直接把字符串返回，也就是把字符串的所有权移出去。

```rust
fn main() {
    let string = no_dangle();
}

fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```

所以说，引用（借用）是没有所有权的。

> 类比生活中的例子就是，你不能把借给你的东西，再借给其他人！！！你只有使用权！没有所有权！

## 切片 Slice 类型

另一个没有所有权的就是切片！其实切片在我理解来，就是取引用中的某一部分。语法大概是这样的：

```rust
fn main() {
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
}
```

其实就是一个引用，`&s` 取引用中的 0 到 5 这么长的数据。

> 就好比，我借给你一个本书，我规定你只能看 0 到 5 页。

所以他的逻辑和引用一样，不一样的就是，我可以截取一部分。

理解了这个，其实像数组或者后面的集合，其实都是一个意思。借用的东西，咱没有所有权。